%
% GNU courseware, XIN YUAN, 2018
%

\section{C++编程的注意点}

\frame{
\centerline{\textbf{\Huge{C++编程的注意点}}}
}

\frame{\frametitle{内存}
大的对象不要定义成局部变量，可能会引起栈溢出。
}

\frame{\frametitle{二元操作}
\begin{itemize}
\item<1-> 分配内存和释放内存。
\item<2-> 加锁和解锁。
\item<3-> 申请系统资源和释放系统资源。
\item<4-> 增加引用计数和减少引用计数。
\end{itemize}
}

\frame{\frametitle{二元操作}
利用析构方法在离开作用域时会自动调用的特性，将二元操作封装成类。
}

\frame{\frametitle{字节序}
\begin{itemize}
\item<1-> 对于需要交换的数据，如读取和写入文件的数据，网络数据包等，
要注意数据类型的大端和小端字节序的问题。
\item<2-> 需要明了装配件自身信息的字节序，以及装配件内数据常量的字节序。
\end{itemize}
}

\frame{\frametitle{字符串编码}
\begin{itemize}
\item<1-> 需要注意装配件内字符串常量的编码格式。
\item<2-> 需要注意源代码文件自身的编码格式。
\end{itemize}
}

\frame{\frametitle{类的层次结构}
\begin{itemize}
\item<1-> 先前软件框架多用单根继承体系，现代观点看并不是很好。
\item<2-> 多重继承比较复杂，不容易看清逻辑，也不适合多人开发，也不是很好。
一般配合接口用在共享装配件中。
\item<3-> 尽量少用继承，多用组合。
\end{itemize}
}

\frame{\frametitle{函数或方法}
\begin{itemize}
\item<1-> 函数或方法参数要指明是in，out还是in/out。
\item<2-> 函数或方法体的开始用断言检查参数有效性。即参数有假设。
\item<3-> 函数或方法体的返回值要注意其生命周期。
\item<4-> 函数或方法调用前检查参数的有效性，调用后检查其返回值。
\item<5-> 尽量不设计和使用递归的函数或方法，因其可能栈溢出。
\item<6-> 函数或方法体内返回错误或抛出异常时，尽量清理已完成的工作，
尽量回复到函数或方法被调用前的状态。
\end{itemize}
}

\frame{\frametitle{异常}
\begin{itemize}
\item<1-> 对于公共装配件，对外提供的函数或方法不抛异常，使用返回值指示错误。
\item<2-> 对于同一个工程中的私有装配件，对外提供的函数或方法可以抛出异常，
因为它们使用的是相同的编译器。
\end{itemize}
}

\frame{\frametitle{同步}
对于函数或方法体内静态局部变量初始化的多线程保护，
可使用double-check的技术来避免重复初始化。
对于某些形式的全局变量也可能需要使用该技术。

~

当double-check一个指针时，因为内存分配-初始化不是完整的原子操作，
可能会使得其他线程得到还未初始化完成的对象。
此时应该double-check一个初始化完成后才设置的标志变量。
}

\frame{\frametitle{绑定}
\begin{enumerate}
\item<1-> 使用指针的优点和缺点。
\item<2-> 两端使用shared\_ptr共享指针的优点和缺点。
\item<3-> 两端分别使用shared\_ptr和weak\_ptr的优点和缺点。
\item<4-> 思考多线程下也能安全调用的方法。
\end{enumerate}
}

\frame{\frametitle{指针}
\begin{enumerate}
\item<1-> 智能指针引用计数的同步(CPU指令锁)存在性能损耗。
\item<2-> 参考Rust语言的内存管理，借鉴拥有者-借用者的概念。
\item<3-> 拥有者使用类自身或者unique\_ptr对象实现，借用者可实现为一个纯指针的RefPtr<T>类。
\item<4-> 静态生命周期判断暂时无法在C++语言层面做到，靠程序员自己的判断。
\item<5-> 拥有-借用-归还可以看成是Attach/Detach方法的概念化。
\end{enumerate}
}

\frame{\frametitle{指针}
\begin{enumerate}
\item<1-> 全局的对象借出可以不用归还，其他无论是栈还是堆上分配内存的对象借出时都需要考虑归还。
需要分析生命周期，对象间生命周期相同的借出一般可以不归还。
若在析构中调用借来的对象，要分析析构的顺序，决定是否先归还。
\item<2-> 把自己或者自己的一部分借给借来的对象时，要分析生命周期，借来的对象先归还自身借来的对象，
再归还自己。
\item<3-> 不能把自己或者自己的一部分借给生命周期无法确定是否小于自己的对象。
\item<4-> 函数、方法调用参数列表中的引用或指针型参数也要看成是一种借用过程，
函数或方法结束时其生命周期也结束，即自动归还。
\item<5-> 借出关系很复杂时，在借出者被修改后，直接或间接(如通过属性改变通知)更新被借者的借来关系。
\end{enumerate}
}

\frame{\frametitle{指针}
\begin{enumerate}
\item<1-> MVVM模式中的属性、通知、命令绑定都要看成是这种借-还的过程。
\item<2-> Window和View层中GUI库的对象使用指针绑定数据，也是一种借用，要注意各成员对象的析构顺序，
若借用者在借出者之后释放，也需要先归还。
\end{enumerate}
}

\frame{\frametitle{新特性}
\begin{enumerate}
\item<1-> 就地赋值，列表初始化(一致初始化)，指定初始化
\item<2-> 结构化绑定(多返回值，性能分析)
\item<3-> 自动推断，声明推断，using
\item<4-> 集合循环语句，std::ranges和std::string\_view，流式管道，并发，协程
\item<5-> 面向概念(concept)的编程范式；模块(module)
\item<6-> std::format (C++20)，随机数
\item<7-> 编译期常量表达式和头文件中全局变量内联定义
\end{enumerate}
}

%end
